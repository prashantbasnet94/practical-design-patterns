# 1. Singleton Pattern

## Definition
The **Singleton Pattern** ensures that a class has only **one instance** and provides a **global point of access** to it. This is useful for managing shared resources like database connections, loggers, or configuration managers.

## Real-World Use Case in This Repo
In `src/container/service.container.ts`, the `ServiceFactory` class uses the Singleton pattern. It ensures that the entire application shares a single factory instance to manage services, preventing duplicate service initialization.

```typescript
// Example from codebase (Simplified)
export class ServiceFactory {
  private static instance: ServiceFactory;
  
  private constructor() {} // Private constructor prevents 'new'

  public static getInstance(): ServiceFactory {
    if (!ServiceFactory.instance) {
      ServiceFactory.instance = new ServiceFactory();
    }
    return ServiceFactory.instance;
  }
}
```

## Basic Challenge
**Goal:** Create a `DatabaseConnection` singleton in `src/1.singleton.practice.ts`.

1.  Create a class `DatabaseConnection`.
2.  Ensure that `new` is disabled (private constructor).
3.  Implement `getInstance()` that returns the same instance every time.

---

## ðŸš€ Advanced Concepts

### 1. Configuration Injection (Lazy Initialization)
Sometimes your Singleton needs data (like an API Key or DB URL) to start.
*   **Problem:** The constructor is private, so you can't pass args easily.
*   **Solution:** Pass the config to `getInstance(config)`. First call initializes it; later calls ignore it.
*   **Practice:** See `src/1.singleton.advanced.practice.ts`.

### 2. Global Shared State (The "Bulletin Board")
The most common use of Singleton is to share a list or state across the entire app.
*   **Example:** A Global Logger.
*   **Why:** If you create `new Logger()` in every file, they each have their own empty list of logs. A Singleton `Logger` ensures all files write to the *same* list.

### 3. Caching & Memory Management
Singletons stay alive for the *entire* app lifecycle. This makes them perfect for caching.
*   **Risk:** If you never clear the cache, it grows forever (Memory Leak).
*   **Method:** Always implement a `clear()` or `reset()` method in your Singleton to manage memory.
