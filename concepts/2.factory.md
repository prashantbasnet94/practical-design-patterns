# 2. Factory Method Pattern

**"The Virtual Constructor"**

## Definition
The **Factory Method Pattern** utilizes an interface or class to create objects, but lets subclasses or helper functions decide which specific class to instantiate.

---

## üîç The "Lens": When to use this pattern?

Use these lenses to identify when you need a Factory:

### 1. The "Unknown Type" Lens
**Trigger:** You don't know exactly what you need to build until runtime.
*   **Example:** A user uploads a file. Is it `.jpg`, `.png`, or `.gif`?
*   **Solution:** A `ImageProcessorFactory.create(fileType)` decides which processor class to return (`JpegProcessor`, `PngProcessor`, etc).

### 2. The "complex Construction" Lens
**Trigger:** Using `new MyObject()` requires 10 lines of setup code (config, dependencies, validation).
*   **Risk:** Copy-pasting those 10 lines everywhere you need the object is a maintenance nightmare.
*   **Solution:** Put those 10 lines inside `Factory.create()`. Now the client just calls one line.

### 3. The "Library Extensions" Lens
**Trigger:** You are writing a library and want users to be able to extend your internal components.
*   **Solution:** Instead of hardcoding `new StandardButton()`, you use a factory `createButton()`. Users can override this factory to return `new CustomButton()`.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Decoupling**: The code that *uses* the object doesn't need to know the specific class of the object. | **Complexity**: Can introduce too many small classes/files for simple objects. |
| **Open/Closed Principle**: You can add new product types without breaking existing client code. | **Indirection**: Sometimes it's harder to read code when you have to jump to a factory to see what's actually being created. |
| **Centralization**: Construction logic is in one place, easy to update. | |

---

## Real-World Use Case in This Repo
In `src/infrastructure/logging/composite.logging.writer.ts`, the `createCompositeLoggingWriter` function acts as a factory. It decides whether to compose just a `ConsoleWriter`, or add a `SentryWriter` and `PostHogWriter` based on the configuration object passed to it.

---

## Your Challenge
**Goal:** Create a `LoggerFactory` that handles different logging destinations.

1.  Create a file named `2.factory.ts`.
2.  Define an interface `ILogger` with a method `log(message: string): void`.
3.  Implement three classes implementing `ILogger`:
    *   `ConsoleLogger`: Prints to `console.log`.
    *   `FileLogger`: Simulates writing to a file (just print "[File] ...").
    *   `CloudLogger`: Simulates sending to AWS (just print "[Cloud] ...").
4.  Create a function/class `LoggerFactory` that takes a type string (`'console' | 'file' | 'cloud'`) and returns the correct `ILogger` instance.
5.  **Verify:** Call your factory request a 'cloud' logger and verify the output.
