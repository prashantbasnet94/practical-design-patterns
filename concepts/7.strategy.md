# 7. Strategy Pattern

**"The Chameleon Pattern"**

## Definition
The **Strategy Pattern** defines a family of algorithms, encapsulates each one, and makes them interchangeable. Strategy lets the algorithm vary independently from clients that use it.

---

## üîç The "Lens": When to use this pattern?

### 1. The "Massive Switch Statement" Lens
**Trigger:** You have a function with 50 lines of `if (type == 'A') ... else if (type == 'B') ...`.
*   **Risk:** Adding type 'C' means modifying this massive, brittle function.
*   **Solution:** Move each block into its own class (`StrategyA`, `StrategyB`). The usage becomes `strategy.execute()`.

### 2. The "Swappable Logic" Lens
**Trigger:** You want to support multiple ways of doing the same thing, chosen at runtime.
*   **Example:** Sorting (QuickSort vs MergeSort), Payment (PayPal vs CreditCard), Compression (Zip vs Rar).
*   **Solution:** Define an interface `sort()`, `pay()`, or `compress()`, and swap implementations on the fly.

### 3. The "Testing Mock" Lens
**Trigger:** You want to test a service but swap out the real logic for a dummy logic.
*   **Solution:** Pass a `MockStrategy` that returns hardcoded values instead of the `RealStrategy`.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Clean Code**: Eliminates large conditional statements (if/else/switch). | **Client Awareness**: The client must know about the differences between strategies to select the right one. |
| **Open/Closed**: Add new strategies without changing the context class. | **Object Overhead**: Increases the number of classes in the system. |
| **Separation of Concerns**: Isolate specific algorithmic logic and implementation details. | |

---

## Real-World Use Case in This Repo
The `AuthProvider` configuration supports multiple strategies (Email/Password, Google OAuth, Microsoft OAuth). The system is designed so you can swap out strict password rules for OAuth without changing the core login flow logic.

---

## Your Challenge
**Goal:** Implement a generic `PaymentContext` that accepts different payment strategies.

1.  Create a file named `7.strategy.ts`.
2.  Define an interface `PaymentStrategy` with method `pay(amount: number): void`.
3.  Implement `CreditCardStrategy`: logs "Paid $X with Credit Card".
4.  Implement `PayPalStrategy`: logs "Paid $X with PayPal".
5.  Implement `CryptoStrategy`: logs "Paid $X with Bitcoin".
6.  Create a `Checkout` class that takes a `PaymentStrategy` in its constructor (or a setter).
7.  **Verify:** Create a checkout with CreditCard, process `100`. Then change strategy to PayPal, process `50`.
