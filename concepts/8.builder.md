# 8. Builder Pattern

**"The Step-by-Step Construction Pattern"**

## Definition
The **Builder Pattern** separates the construction of a complex object from its representation. It allows you to create different representations using the same construction process, often via method chaining.

---

## üîç The "Lens": When to use this pattern?

### 1. The "Telescoping Constructor" Lens
**Trigger:** Your constructor looks like `new User(name, null, null, 25, true, null, 'admin')`.
*   **Risk:** It's impossible to remember which `null` is which argument.
*   **Solution:** `new UserBuilder().setName('Bob').setAge(25).isAdmin().build()`. Readable and flexible.

### 2. The "Complex Config" Lens
**Trigger:** Initializing an object requires 10 distinct steps that must happen in a certain order.
*   **Solution:** The Builder handles the complexity (`step1()`, `step2()`) and validation, preventing invalid objects from being created.

### 3. The "Immutability" Lens
**Trigger:** You want your final object to be Immutable (read-only), but it has too many fields to pass into a constructor cleanly.
*   **Solution:** The Builder gathers the data (mutable), and `build()` returns the frozen, immutable object.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Fluid Interface**: Method chaining (`.a().b().c()`) makes creation code very readable. | **Verbosity**: Requires creating a separate Builder class for each Product type. |
| **Validation**: You can defer object creation until `build()` is called, ensuring the object is valid. | **Duplication**: Does the Builder need to duplicate all fields of the Product? Often yes. |
| **Immutability**: Ideal for creating immutable objects. | |

---

## Real-World Use Case in This Repo
We use **Drizzle ORM** extensively, which uses a query builder pattern:
```typescript
db.select().from(users).where(eq(users.id, 1));
```
This is much safer and cleaner than concatenating SQL strings manually.

---

## Your Challenge
**Goal:** Implement a `PizzaBuilder` to construct a custom pizza object.

1.  Create a file named `8.builder.ts`.
2.  Define a class `Pizza` with properties: `size`, `cheese`, `pepperoni`, `mushrooms`.
3.  Create a `PizzaBuilder` class.
    *   Methods: `setSize(size)`, `addCheese()`, `addPepperoni()`, `addMushrooms()`.
    *   Each method should return `this` (the builder instance) to allow chaining.
    *   Method `build()` returns the final `Pizza` object.
4.  **Verify:** `new PizzaBuilder().setSize('large').addCheese().addPepperoni().build()`.
