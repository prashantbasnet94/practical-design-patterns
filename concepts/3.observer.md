# 3. Observer Pattern (Pub/Sub)

**"Don't call us, we'll call you."**

## Definition
The **Observer Pattern** (often implemented as Publish/Subscribe) defines a one-to-many dependency between objects so that when one object (Subject) changes state, all its dependents (Observers) are notified and updated automatically.

---

## üîç The "Lens": When to use this pattern?

Use these lenses to identify when you need an Observer:

### 1. The "Decoupling" Lens
**Trigger:** Module A (User Registration) needs to trigger Module B (Email) and Module C (Analytics), but you don't want Module A importing B and C.
*   **Solution:** Module A emits an event `USER_REGISTERED`. B and C subscribe to it. A knows nothing about B or C.

### 2. The "Event Driven" Lens
**Trigger:** You are building a UI where clicking a button needs to update a header, a sidebar, and a popup.
*   **Risk:** Writing one giant function `onClick()` that touches every part of the DOM is messy.
*   **Solution:** `onClick` emits `BUTTON_CLICKED`. The independent UI components listen and update themselves.

### 3. The "Dynamic Relationships" Lens
**Trigger:** The list of who needs to be notified changes at runtime.
*   **Example:** A user "Follows" a stock. They only receive updates for that specific stock while following.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Open/Closed Principle**: You can introduce new subscriber classes without breaking the publisher. | **Debugging Hell**: "Who triggered this?" The flow of control is inverted and invisible in the code. |
| **Runtime configuration**: You can add/remove observers on the fly. | **Memory Leaks**: If observers fail to unsubscribe they continue to exist (common in SPAs). |
| **Decoupling**: Publisher is blissfully unaware of the complexity of its subscribers. | **Ordering**: You cannot rely on which subscriber runs first. |

---

## Real-World Use Case in This Repo
In `src/infrastructure/metrics/metrics.bus.ts`, the `MetricsBus` is a classic Pub/Sub implementation. Services like `UserService` emit events (e.g., "User Created"), and the `MetricsBus` buffers and dispatches these to registered listeners (like Sentry or Logger) without the `UserService` knowing who is listening.

---

## Your Challenge
**Goal:** Build a simple `EventBus` for an E-commerce system.

1.  Create a file named `3.observer.ts`.
2.  Define a class `EventBus`.
3.  Implement a method `subscribe(event: string, callback: Function)`.
4.  Implement a method `publish(event: string, data: any)`.
5.  **Usage Scenario:**
    *   An "OrderService" publishes `ORDER_PLACED`.
    *   An "EmailService" (subscriber) listens and logs "Sending confirmation email...".
    *   An "InventoryService" (subscriber) listens and logs "Deducting stock...".
6.  **Verify:** Trigger one publish and ensure both subscribers react.
