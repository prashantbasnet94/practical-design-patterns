# The Adapter Pattern

**"The Connector between Clean Code and the Messy Real World"**

The Adapter Pattern is a structural design pattern that allows objects with incompatible interfaces to collaborate. It acts as a wrapper that translates calls from your application into a format that a 3rd party or legacy class understands.

---

## ðŸ” The "Lens": When to use this pattern?

Use these 3 lenses to identify when you need an Adapter in your repo:

### 1. The "Vendor Lock-in" Lens
**Trigger:** You are importing a specific library (e.g., `aws-sdk`, `stripe`, `redis`) directly into your business logic.
*   **Risk:** If you switch providers (AWS -> Google, Stripe -> PayPal), you have to rewrite your core application logic.
*   **Solution:** Define your *own* interface (`IFileStorage`, `IPayment`). Create an Adapter (`AwsAdapter`, `StripeAdapter`) implementation.
*   **Benefit:** Your app becomes **Vendor Agnostic**.

### 2. The "Legacy Migration" Lens
**Trigger:** You are interacting with an old, "ugly" system (bad function names, weird data types) from your new clean code.
*   **Risk:** The "messiness" of the legacy system leaks into your clean code (e.g., using `user_id_str` everywhere instead of `userId`).
*   **Solution:** Build a "Corruption Layer" Adapter. It takes your clean commands and translates them into the "ugly" calls the old system needs.

### 3. The "Testability" Lens
**Trigger:** You can't run your code locally because it demands a real database connection or sends real emails.
*   **Risk:** Development is slow, flaky, and requires internet access.
*   **Solution:** Use an Adapter for the infrastructure.
    *   **Prod:** `EmailAdapter` -> Sends real email.
    *   **Dev:** `ConsoleLogAdapter` -> Just logs "Email sent".
    
---

## ðŸ’¡ The Golden Rule

> Define the Interface **YOU** want first. Then write the Adapter to make the outside world match it. 
> **Don't let the outside world dictate your interface.**

---

## âš¡ Code Comparison

### ðŸ”´ The Anti-Pattern (Without Adapter)
Tight coupling to specific tools. Hard to change.
```typescript
class NotificationManager {
    notify(msg: string) {
        // Tightly coupled to Slack! 
        // If we want Discord, we have to change this code.
        slackClient.postMessage(msg); 
    }
}
```

### ðŸŸ¢ The Pattern (With Adapter)
Decoupled and open for extension.
```typescript
// 1. We define the contract WE want
interface INotifier {
    send(msg: string): void;
}

// 2. We adapt the tool to fit OUR contract
class SlackAdapter implements INotifier {
    send(msg: string) {
        slackClient.postMessage(msg);
    }
}

// 3. Our manager doesn't care what tool is used
class NotificationManager {
    constructor(private notifier: INotifier) {}
    
    notify(msg: string) {
        this.notifier.send(msg);
    }
}
```
