# 6. Adapter Pattern

## Definition
The **Adapter Pattern** allows objects with incompatible interfaces to collaborate. It acts as a wrapper that translates calls from the client to calls that the wrapped object understands.

## Real-World Use Case in This Repo
In `src/lib/auth.provider.ts`, we use `drizzleAdapter` from the `better-auth` library. Our database (Drizzle ORM) speaks one language, but `better-auth` expects a specific interface. The adapter bridges this gap so we can plug Drizzle into the auth library effortlessly.

## Your Challenge
**Goal:** Adapt a legacy "OldPrinter" to work with a modern "IPrinter" interface.

1.  Create a file named `6.adapter.ts`.
2.  Define the target interface `IPrinter` with `print(text: string)`.
3.  Define the `OldPrinter` class (the legacy/3rd party code) which only has `printEncrypted(hex: string)`. It expects a hex string!
4.  Create an `PrinterAdapter` class that implements `IPrinter`.
    *   It wraps an `OldPrinter`.
    *   In `print(text)`, it converts the text to Hex (mock logic is fine) and calls `legacy.printEncrypted()`.
5.  **Verify:** Creates `new PrinterAdapter(new OldPrinter())` and call `.print("Hello")`. Ensure the legacy method receives it.

### Bonus
Consider how you would handle errors if the legacy printer throws an exception (should the adapter swallow it or rethrow it?).
