# 9. Facade Pattern

**"The Dashboard View"**

## Definition
The **Facade Pattern** provides a simplified interface to a library, a framework, or any other complex set of classes. It hides the complexity of the subsystem from the client.

---

## üîç The "Lens": When to use this pattern?

### 1. The "Complexity Wall" Lens
**Trigger:** To do one simple thing (e.g., "Start Computer"), you have to import and coordinate 10 different subsystem classes (`CPU`, `RAM`, `HDD`, `GPU`...).
*   **Risk:** Client code becomes tightly coupled to the implementation details of your subsystems.
*   **Solution:** Create a `ComputerFacade` with one method `start()`. All the complexity is hidden behind it.

### 2. The "3rd Party Lib" Lens
**Trigger:** You are using a massive, complex library (like `jQuery` or `ThreeJS`) but you only need 5% of its features.
*   **Solution:** Create your own Facade (Wrapper) that exposes only the 5% you care about. This decouples your app from the library, making it easier to replace later.

### 3. The "Layered Architecture" Lens
**Trigger:** You want to force strict layering. The UI layer should not talk to the Database layer directly.
*   **Solution:** The Service Layer acts as a Facade for the Domain/Database logic.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Simplicity**: Dramatically reduces the learning curve for using a complex system. | **God Object**: Facades can become too big if they try to expose *every* feature of the subsystem. |
| **Decoupling**: Changes to the subsystem (e.g., upgrading a library) only affect the Facade, not the rest of the app. | **Performance**: Adds a tiny layer of indirection (usually negligible). |

---

## Real-World Use Case in This Repo
Our `ServiceFactory` acts as a massive Facade. When the `OrganizationController` needs to work, it just asks `ServiceFactory.getInstance().getOrgService()`. It doesn't need to know that `OrgService` depends on `OrgRepository`, which depends on `MetricsBus` and `DatabaseConnection`. The Factory/Facade hides that wiring complexity.

---

## Your Challenge
**Goal:** Create a `ComputerFacade` that turns on the computer by coordinating sub-parts.

1.  Create a file named `9.facade.ts`.
2.  Create complex subsystem classes with `start()` methods: `CPU`, `Memory`, `HardDrive`.
3.  Create a `ComputerFacade` class.
    *   Constructor initializes the subsystems.
    *   Method `startComputer()` calls:
        1.  `CPU.freeze()`
        2.  `Memory.load(BOOT_ADDRESS)`
        3.  `HardDrive.read(BOOT_SECTOR)`
        4.  `CPU.jump(BOOT_ADDRESS)`
        5.  `CPU.execute()`
4.  **Verify:** The client just calls `computer.startComputer()` and sees the sequence of logs.
