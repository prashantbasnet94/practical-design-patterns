# 4. Composite Pattern

**"Treat the Whole the same as the Part"**

## Definition
The **Composite Pattern** allows you to compose objects into tree structures to represent part-whole hierarchies. It lets clients treat individual objects (Leaf) and compositions of objects (Composite) uniformly.

---

## üîç The "Lens": When to use this pattern?

To use this pattern, you must have a "Tree Structure" in your data.

### 1. The "Recursive Operations" Lens
**Trigger:** You want to run an operation (like `calculateTotal()`) on a Group, and have it magically cascade down to all sub-groups and items.
*   **Example:** Calculating the total size of a Directory (which contains Files and other Directories).
*   **Solution:** Both File and Directory implement `getSize()`. Directory just sums up its children.

### 2. The "Uniformity" Lens
**Trigger:** You have "Containers" and "Contents", but you want to treat them identically.
*   **Example:** A GUI Drawing app. You can Group shapes together. You want to be able to `move()` a single Square, or `move()` a Group of Squares, using the exact same code.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Simplified Client Code**: Client doesn't need to check `if (node is Folder)`. Just calls `node.operation()`. | **Overly General**: It's hard to restrict what goes *into* the composite (e.g., if you only want Folders to hold Files, not other Folders). |
| **Easy Expansion**: You can add new Leaf types easily. | **Code Tracing**: Recursive calls can be hard to step through in a debugger. |

---

## Real-World Use Case in This Repo
In `src/infrastructure/logging/composite.logging.writer.ts`, the `CompositeLoggingWriter` holds a list of other writers. When `write()` is called on it, it iterates and calls `write()` on all children. The client using it doesn't know (or care) if it's talking to one logger or five.

---

## Your Challenge
**Goal:** Build a `FileSystem` structure where `Folder` and `File` are treated uniformly.

1.  Create a file named `4.composite.ts`.
2.  Define an interface `FileSystemComponent` with a method `getSize(): number`.
3.  Implement `File` class:
    *   Constructor takes a `size: number`.
    *   `getSize()` returns that size.
4.  Implement `Folder` class:
    *   Holds a list of `FileSystemComponent` children.
    *   Has an `add(component: FileSystemComponent)` method.
    *   `getSize()` returns the **sum** of all children's sizes.
5.  **Verify:** Create a folder `root`, add two files (size 10 and 20), and a subfolder with one file (size 5). `root.getSize()` should return 35.
