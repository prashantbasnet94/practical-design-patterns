# 5. Decorator Pattern

**"The Russian Nesting Doll Pattern"**

## Definition
The **Decorator Pattern** allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. It wraps the original object to provide new functionality.

---

## üîç The "Lens": When to use this pattern?

### 1. The "Option Explosion" Lens
**Trigger:** You have a base class `Coffee`, and you start creating subclasses like `CoffeeWithMilk`, `CoffeeWithSugar`, `CoffeeWithMilkAndSugar`, `DecafCoffeeWithMilk`...
*   **Risk:** This is called "Class Explosion". The combinations are endless.
*   **Solution:** Use Decorators. `new Milk(new Sugar(new Coffee()))`. You mix and match at runtime.

### 2. The "Legacy Wrapper" Lens
**Trigger:** You have a class you can't modify (e.g., from a library), but you need it to log every time it's called.
*   **Solution:** Wrap it in a `LoggingDecorator`. The rest of your app uses the wrapper, thinking it's the original.

### 3. The "Dynamic Features" Lens
**Trigger:** You want to toggle features on/off for specific users (e.g., Admin gets extra buttons).
*   **Solution:** Decorate the `UserRenderer` with `AdminToolsDecorator` only if they are an admin.

---

## ‚öñÔ∏è Pros & Cons

| Pros | Cons |
| :--- | :--- |
| **Extensibility**: Add behavior without extending/subclassing. | **Small Object Proliferation**: Codebase gets cluttered with tiny wrapper classes. |
| **Flexibility**: Combine behaviors in any order (Milk then Sugar, or Sugar then Milk). | **Identity Crisis**: `decorator !== original_object`. Comparing object identity (`===`) fails. |
| **SRP**: Each decorator does one specific thing nicely. | **Debug Trace**: Stepping into a method means stepping through 5 layers of wrappers. |

---

## Real-World Use Case in This Repo
In Fastify (and our `app.decorators.ts`), we "decorate" the app instance or request object with new methods like `authenticate` or `rbac`. While slightly functional in nature, the concept is the same: enhancing the core object with layers of capabilities.

---

## Your Challenge
**Goal:** Enhance a simple `Coffee` order with extras using decorators.

1.  Create a file named `5.decorator.ts`.
2.  Define an interface `Coffee` with:
    *   `cost(): number`
    *   `description(): string`
3.  Implement a concrete `SimpleCoffee` class (Cost: 10, Desc: "Coffee").
4.  Implement a `MilkDecorator` class:
    *   Takes a `Coffee` object in constructor.
    *   Adds 2 to cost.
    *   Appends ", Milk" to description.
5.  Implement a `SugarDecorator` class:
    *   Takes a `Coffee` object.
    *   Adds 1 to cost.
    *   Appends ", Sugar" to description.
6.  **Verify:** Create `new SugarDecorator(new MilkDecorator(new SimpleCoffee()))`. Check if cost is 13 and desc is "Coffee, Milk, Sugar".
