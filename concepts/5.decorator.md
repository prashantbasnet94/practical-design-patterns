# 5. Decorator Pattern

## Definition
The **Decorator Pattern** allows behavior to be added to an individual object, dynamically, without affecting the behavior of other objects from the same class. It wraps the original object to provide new functionality.

## Real-World Use Case in This Repo
In Fastify (and our `app.decorators.ts`), we "decorate" the app instance or request object with new methods like `authenticate` or `rbac`. While slightly functional in nature, the concept is the same: enhancing the core object with layers of capabilities.

## Your Challenge
**Goal:** Enhance a simple `Coffee` order with extras using decorators.

1.  Create a file named `5.decorator.ts`.
2.  Define an interface `Coffee` with:
    *   `cost(): number`
    *   `description(): string`
3.  Implement a concrete `SimpleCoffee` class (Cost: 10, Desc: "Coffee").
4.  Implement a `MilkDecorator` class:
    *   Takes a `Coffee` object in constructor.
    *   Adds 2 to cost.
    *   Appends ", Milk" to description.
5.  Implement a `SugarDecorator` class:
    *   Takes a `Coffee` object.
    *   Adds 1 to cost.
    *   Appends ", Sugar" to description.
6.  **Verify:** Create `new SugarDecorator(new MilkDecorator(new SimpleCoffee()))`. Check if cost is 13 and desc is "Coffee, Milk, Sugar".

### Bonus
Create a `LoggingDecorator` for a Service class that logs "Execution start" and "Execution end" around the real method call.
